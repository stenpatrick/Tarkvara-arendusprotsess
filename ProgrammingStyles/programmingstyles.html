<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UML</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="../index.css">
</head>
<body class="bg-gray-200 font-sans">
    <div class="container mx-auto py-8">
        <h1 id="whiteoutline" style="color: white; font-family: 'Comic Sans MS';">Programming styles</h1>
        <hr class="border-blue-500 mb-8">
        <div class="p-4 bg-white shadow-md rounded">
        <ul>
        <main class="w-1/2 flex flex-col gap-8 text-wrap">

        <h2 id="whiteinline" style="color: #404040; font-family: 'Comic Sans MS';"><a id="textcolor">Behavior-driven development</a></h2>
        <p>
            <a id="textcolor">Behavior-driven development, or BDD, is a software development methodology that encourages collaboration between developers, quality assurance experts, and representatives from the business side. It encourages teams to use conversation and concrete examples to formalize a shared understanding of how an application should behave.
        </p>
        <li id="textcolor"><strong><a id="textcolor">Pros</a></strong></li>
        <ul class="list-disc text-left">
            <li><a id="textcolor">Improved Collaboration</a></li>
            <li><a id="textcolor">Shared Understanding</a></li>
            <li><a id="textcolor">Focus on Behavior</a></li>
            <li><a id="textcolor">Automated Tests</a></li>
            <li><a id="textcolor">Early Detection of Issues</a></li>
        </ul>
        <li id="textcolor"><strong><a id="textcolor">Cons</a></strong></li>
        <ul class="list-disc text-left">
            <li><a id="textcolor">Initial Learning Curve</a></li>
            <li><a id="textcolor">Time-Consuming Process</a></li>
            <li><a id="textcolor">Overemphasis on Test Automation</a></li>
            <li><a id="textcolor">Maintenance of Tests</a></li>
            <li><a id="textcolor">Dependency on Stakeholder Availability</a></li>
        </ul>
        <h2 id="whiteinline" style="color: #404040; font-family: 'Comic Sans MS';">Design-driven development</h2>
        <p>
            <a id="textcolor">Design-driven development prioritizes user experience, making design the driving force behind product creation.</p></a>
        </p>             
        <h3 id="textcolor">Stages:</h3>
            <ol class="list-decimal text-left">
                <li><a id="textcolor">User research<br/></a></li>
                <li><a id="textcolor">Requirement gathering<br/></a></li>
                <li><a id="textcolor">Design and ideation phase<br/></a></li>
                <li><a id="textcolor">Prototype and user testing design<br/></a></li>
                <li><a id="textcolor">Design and development work distribution<br/></a></li>
                <li><a id="textcolor">Iterative feedback loop<br/></a></li>
                <li><a id="textcolor">Initiation and iteration (final phase)<br/></a></li>
            </ol>
            <li id="textcolor"><strong><a id="textcolor">Pros</a></strong></li>
            <ul class="list-disc text-left">
                <li><a id="textcolor">Focuses on User Experience</a></li>
                <li><a id="textcolor">Clear Design Goals</a></li>
                <li><a id="textcolor">Iterative Feedback Loop</a></li>
                <li><a id="textcolor">Emphasizes User Research</a></li>
                <li><a id="textcolor">Aligns Design and Development</a></li>
            </ul>
            <li id="textcolor"><strong><a id="textcolor">Cons</a></strong></li>
            <ul class="list-disc text-left">
                <li><a id="textcolor">Requires Skilled Designers</a></li>
                <li><a id="textcolor">May Overlook Technical Feasibility</a></li>
                <li><a id="textcolor">Time-Consuming User Research</a></li>
                <li><a id="textcolor">Iterative Process Can Extend Timelines</a></li>
                <li><a id="textcolor">Dependency on User Feedback</a></li>
            </ul>
        </p>
            <h2 id="whiteinline" style="color: #404040; font-family: 'Comic Sans MS';">Domain-driven design</h2>
                <p>
                    <a id="textcolor">
                    Domain-driven design (DDD) is a primary approach to software design that focuses on modeling software to match a domain according to input from domain experts.

                    In domain-driven design, the structure and language of the software code (class names, class methods, class variables) should align with the business domain. For example, if the software deals with loan applications, it might have classes such as "loan application," "customers," and methods such as "accept offer" and "withdrawal."

                    Domain-driven design is based on the following objectives:

                    <ul class="list-disc text-left">
                        <a id="textcolor">Placing the project's main focus on the core domain and domain logic.</a>
                        <a id="textcolor">Building complex designs based on the domain model.</a>
                        <a id="textcolor">Initiating creative collaboration between technical and domain experts to iteratively refine a conceptual model that addresses specific domain problems.</a>
                    </ul>
                   </a>    
                </p>
                <li id="textcolor"><strong><a id="textcolor">Pros</a></strong></li>
                <ul class="list-disc text-left">
                    <li><a id="textcolor">Enhanced Focus on Domain Logic</a></li>
                    <li><a id="textcolor">Better Alignment with Business Domain</a></li>
                    <li><a id="textcolor">Encourages Collaboration between Experts</a></li>
                    <li><a id="textcolor">Allows for Iterative Refinement</a></li>
                    <li><a id="textcolor">Facilitates Complex Design</a></li>
                </ul>
                <li id="textcolor"><strong><a id="textcolor">Cons</a></strong></li>
                <ul class="list-disc text-left">
                    <li><a id="textcolor">Requires Understanding of Domain Concepts</a></li>
                    <li><a id="textcolor">May Lead to Over-engineering</a></li>
                    <li><a id="textcolor">Can Be Time-Consuming</a></li>
                    <li><a id="textcolor">Dependency on Domain Experts</a></li>
                    <li><a id="textcolor">Complexity in Implementation</a></li>
                </ul>
        
        <h2 id="whiteinline" style="color: #404040; font-family: 'Comic Sans MS';">Secure by design</h2>
        <p>
            <a id="textcolor">
            Secure by design in software engineering means that software products and features are inherently designed to be secure.

            Alternative security strategies, tactics, and patterns are considered at the beginning of software design, and the best ones are selected and enforced by architecture and used as guiding principles for developers. 
            It is also recommended to use strategic design patterns that have a beneficial impact on security, even though these design patterns were not originally developed with security in mind.
            </a>
        </p>
        <li id="textcolor"><strong><a id="textcolor">Pros</a></strong></li>
        <ul>
            <li id="textcolor">Enhances overall security posture.</li>
            <li id="textcolor">Reduces vulnerabilities and potential exploits.</li>
            <li id="textcolor">Enforces best security practices.</li>
            <li id="textcolor">Increases awareness of security considerations from the outset.</li>
        </ul>
        <li id="textcolor"><strong><a id="textcolor">Cons</a></strong></li>
        <ul>
            <li id="textcolor">May require additional time and effort during the initial design phase.</li>
            <li id="textcolor">Developers may need specialized training or expertise in security.</li>
            <li id="textcolor">Stricter security measures could potentially limit flexibility.</li>
            <li id="textcolor">Complexity may increase due to the integration of security measures.</li>
        </ul>
        <h2 id="whiteinline" style="color: #404040; font-family: 'Comic Sans MS';">Test-driven development</h2>
        <p>
            <a id="textcolor">
            Test Driven Development (TDD) is a software development approach where tests are written before actual code. It has several advantages: Comprehensive test coverage: TDD ensures that all new code is covered by at least one test, resulting in stronger software.
            <li id="textcolor"><strong><a id="textcolor">Pros</a></strong></li>
            <ul>
                <li id="textcolor">Comprehensive test coverage: TDD ensures that all new code is covered by at least one test, resulting in stronger software.</li>
                <li id="textcolor">Immediate feedback: Developers get immediate feedback on whether their code works as expected, leading to faster bug detection and fixing.</li>
                <li id="textcolor">Design improvement: TDD encourages developers to focus on writing clean, modular code, which often leads to better overall software design.</li>
            </ul>
            <li id="textcolor"><strong><a id="textcolor">Cons</a></strong></li>
            <ul>
                <li id="textcolor">Initial learning curve: Adopting TDD may require developers to learn new tools and practices, which can slow down development initially.</li>
                <li id="textcolor">Increased time: Writing tests before code can increase the time required to deliver a feature, especially in the beginning when developers are less experienced with TDD.</li>
                <li id="textcolor">Potential over-testing: TDD might lead to excessive testing, where developers focus too much on writing tests for every small piece of functionality, which can be time-consuming and unnecessary.</li>
            </ul>
            </a>
        </p>
        <h2 id="whiteinline" style="color: #404040; font-family: 'Comic Sans MS';">Acceptance test-driven development</h2>
        <p>
            <a id="textcolor">
            TDD encourages writing testable, loosely coupled code, which tends to be more modular. As well-structured modular code is easier to write, debug, understand, maintain, and reuse, TDD helps:
            </a>
            <ul class="list-disc mr-5">
                <li><a id="textcolor">Reduce costs<br/></a></li>
                <li><a id="textcolor">Make refactoring and rewriting easier and faster ("make it work" stages with red and green, then refactor to "make it right")<br/></a></li>
                <li><a id="textcolor">Smooth project integration<br/></a></li>
                <li><a id="textcolor">Avoid errors and binding<br/></a></li>
                <li><a id="textcolor">Enhance overall team collaboration<br/></a></li>
                <li><a id="textcolor">Increase confidence that code works as expected<br/></a></li>
                <li><a id="textcolor">Improve code patterns<br/></a></li>
                <li><a id="textcolor">Eliminate fear of changes<br/></a></li>
            </ul>
        </p>
        <li id="textcolor"><strong><a id="textcolor">Pros</a></strong></li>
        <ul>
            <li id="textcolor">Comprehensive test coverage: TDD ensures that all new code is covered by at least one test, resulting in stronger software.</li>
            <li id="textcolor">Early detection of bugs and issues.</li>
            <li id="textcolor">Encourages better-designed software through incremental development.</li>
            <li id="textcolor">Improved code quality and maintainability.</li>
        </ul>
        </h3 id="textcolor">
        <li id="textcolor"><strong><a id="textcolor">Cons</a></strong></li>
        <ul>
            <li id="textcolor">Requires a paradigm shift in development approach, which may take time for developers to adapt.</li>
            <li id="textcolor">Initial setup and writing tests may add overhead to development time.</li>
            <li id="textcolor">Complexity may increase if tests are not well-designed or maintained.</li>
            <li id="textcolor">May not be suitable for all types of projects or teams.</li>
        </ul>
        <h2 id="whiteinline" style="color: #404040; font-family: 'Comic Sans MS';">Continuous test-driven development</h2>
        <p>
            <a id="textcolor">
            Continuous Test-Driven Development (CTDD) is a software development practice that extends test-driven development (TDD) by incorporating continuous testing, sometimes referred to as continuous testing.
            </a>
            <li id="textcolor"><strong><a id="textcolor">Pros</a></strong></li>
            <ul>
                <li id="textcolor">Reduced risk: Continuous testing helps in identifying issues early, reducing the risk of critical failures in production.</li>
                <li id="textcolor">Greater agility: CTDD enables faster feedback loops, allowing teams to adapt to changes and deliver updates more frequently.</li>
                <li id="textcolor">Enhanced collaboration: By integrating testing into the development process, CTDD fosters collaboration between developers and testers, leading to a shared understanding of requirements and quality standards.</li>
            </ul>
            <li id="textcolor"><strong><a id="textcolor">Cons</a></strong></li>
            <ul>
                <li id="textcolor">Complex setup: Implementing CTDD requires setting up automated testing frameworks and continuous integration systems, which can be complex and time-consuming.</li>
                <li id="textcolor">Resource-intensive: Maintaining a continuous testing environment requires significant resources in terms of infrastructure, tools, and personnel.</li>
                <li id="textcolor">Dependency on tooling: CTDD heavily relies on automation tools, and any issues with these tools can disrupt the development process.</li>
            </ul>
        </p>
        <h2 id="whiteinline" style="color: #404040; font-family: 'Comic Sans MS';">Specification by example</h2>
        <p>
            <a id="textcolor">
            Specification by Example is a collaborative approach to defining software product requirements and business-focused functional tests based on capturing and illustrating requirements using realistic examples instead of abstract statements. It is applied in the context of agile software development methods, especially in the context of behavior-driven development. This approach is particularly successful in managing requirements and functional tests in large-scale projects where domain and organizational complexity is significant. It has several advantages and disadvantages:
            <ul>
                <li id="textcolor"><strong><a id="textcolor">Pros</a></strong></li>
                <ul>
                    <li id="textcolor">Clear communication: Specification by Example helps ensure that everyone involved in the project, including developers, testers, and stakeholders, has a clear understanding of the requirements through concrete examples.<br/><br/></li>
                    <li id="textcolor">Validation of requirements: By using realistic examples, this approach enables early validation of requirements, reducing the likelihood of misunderstandings and rework later in the development process.</li>
                    <li id="textcolor">Alignment with business goals: Specification by Example focuses on capturing requirements in terms of business objectives, ensuring that the software meets the needs of its intended users and stakeholders.</li>
                    <li id="textcolor">Continuous feedback: This approach promotes continuous collaboration and feedback among team members, leading to faster identification and resolution of issues.</li>
                </ul>
                <li id="textcolor"><strong><a id="textcolor">Cons</a></strong></li>
                <ul>
                    <li id="textcolor">Time-consuming: Creating and maintaining realistic examples can be time-consuming, especially in complex projects with numerous scenarios and edge cases.</li>
                    <li id="textcolor">Dependency on domain knowledge: Specification by Example requires a deep understanding of the domain and business processes, which may be challenging to achieve, especially for new team members.</li>
                    <li id="textcolor">Resistance to change: Stakeholders and team members may resist adopting this approach if they are accustomed to traditional methods of requirement gathering and documentation.</li>
                    <li id="textcolor">Over-reliance on examples: There is a risk of focusing too much on specific examples at the expense of considering alternative solutions or edge cases that may not be adequately covered.</li>
                </ul>
            </ul>
            </a>
        </p>
        <h2 id="whiteinline" style="color: #404040; font-family: 'Comic Sans MS';">Data-driven development</h2>
        <p>            
            <a id="textcolor">
                Data-driven development is a process where data is the primary driving force behind design and development decisions. It has become an increasingly popular way of developing software as companies have realized the benefits of data-driven decision-making. In this blog post, we define data-driven development, explain its advantages, and provide tips on how to make the most of it. It has several advantages and disadvantages:
            <ul>
                <li id="textcolor"><strong><a id="textcolor">Pros</a></strong></li>
                <ul>
                    <li id="textcolor">Informed decision-making: Data-driven development allows teams to make decisions based on empirical evidence rather than assumptions or gut feelings, leading to more accurate and effective choices.</li>
                    <li id="textcolor">Improved user experience: By analyzing user data and feedback, developers can better understand user needs and preferences, resulting in software that meets user expectations and drives higher user satisfaction.</li>
                    <li id="textcolor"i>Optimized features: Data-driven development enables prioritization of features and enhancements based on their impact on key metrics, ensuring that development efforts are focused on areas that deliver the most value to users and the business.</li>
                    <li id="textcolor">Rapid iteration: The continuous collection and analysis of data allow teams to iterate quickly, making adjustments and improvements based on real-world usage and feedback.</li>
                </ul>
                <li id="textcolor"><strong><a id="textcolor">Cons</a></strong></li>
                <ul>
                    <li id="textcolor">Data quality issues: Data-driven development relies on the availability and accuracy of data, and issues such as incomplete or biased data can lead to flawed decision-making and development outcomes.</li>
                    <li id="textcolor">Overemphasis on metrics: Focusing solely on data-driven metrics may neglect qualitative aspects of software development, such as user experience and creativity, leading to a potentially limited and uninspired product.</li>
                    <li id="textcolor">Privacy and ethical concerns: Collecting and analyzing user data raises privacy and ethical considerations, and companies must ensure compliance with regulations and ethical standards to avoid potential backlash and legal issues.</li>
                    <li id="textcolor"i>Dependency on tools and infrastructure: Implementing data-driven development requires investment in tools, infrastructure, and expertise for data collection, analysis, and visualization, which can be costly and complex.</li>
                </ul>
            </ul>
            </a>
            <p>            
                <a id="textcolor">
                    </p>
                    <h2 id="whiteinline" style="color: #404040; font-family: 'Comic Sans MS';">Data-oriented design</h2>
                <p>
                    Data-oriented design is a software design approach that focuses on organizing data in a way that makes accessing and manipulating it easy. It is based on the idea that the primary focus of a program should be on data, rather than operations or transformations performed on that data. It has several advantages and disadvantages:
                    <ul>
                        <li id="textcolor"><strong><a id="textcolor">Pros</a></strong></li>
                        <ul>
                            <li id="textcolor">Performance optimization: Data-oriented design can lead to improved performance by optimizing data layout and access patterns, resulting in faster data processing and reduced memory usage.</li>
                            <li id="textcolor">Scalability: By focusing on data organization and access efficiency, data-oriented design can make it easier to scale applications to handle larger datasets and higher workloads.</li>
                            <li id="textcolor">Maintainability: Clear data organization and separation of concerns in data-oriented design can improve code maintainability, making it easier to understand, debug, and modify code as requirements change.</li>
                            <li id="textcolor">Flexibility: Data-oriented design can provide greater flexibility in adapting to evolving requirements and accommodating changes in data structures or processing logic.</li>
                        </ul>
                        <li id="textcolor"><strong><a id="textcolor">Cons</a></strong></li>
                        <ul>
                            <li id="textcolor">Learning curve: Adopting data-oriented design may require developers to learn new concepts and techniques for data organization and access, which can pose a learning curve, especially for those accustomed to traditional object-oriented design.</li>
                            <li id="textcolor">Complexity: Designing systems with a focus on data can introduce additional complexity, especially in cases where data structures are highly interconnected or require complex transformations.</li>
                            <li id="textcolor">Over-engineering: There is a risk of over-engineering or premature optimization when applying data-oriented design, leading to unnecessary complexity and decreased maintainability.</li>
                            <li id="textcolor">Trade-offs: Data-oriented design involves trade-offs, and optimizing for one aspect, such as performance, may come at the expense of other factors like code readability or development speed.</li>
                        </ul>
                    </ul>
                </a>
            </p>
                </main>
</body>
</html>
